import e from"node:process";import{Buffer as t}from"node:buffer";import n from"node:path";import r,{ChildProcess as i}from"node:child_process";import o from"child_process";import s from"path";import a from"fs";import c,{fileURLToPath as d}from"node:url";import{constants as u}from"os";import l,{constants as p}from"node:os";import m from"assert";import f from"events";import h from"buffer";import g from"stream";import b from"util";import{createWriteStream as y,createReadStream as w}from"node:fs";import{setTimeout as x}from"node:timers/promises";import{debuglog as S,promisify as I}from"node:util";var v="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function E(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var T,C,G,P,A,k={exports:{}};A="win32"===process.platform||v.TESTING_WINDOWS?function(){if(C)return T;C=1,T=n,n.sync=function(n,r){return t(e.statSync(n),n,r)};var e=a;function t(e,t,n){return!(!e.isSymbolicLink()&&!e.isFile())&&function(e,t){var n=void 0!==t.pathExt?t.pathExt:process.env.PATHEXT;if(!n)return!0;if(-1!==(n=n.split(";")).indexOf(""))return!0;for(var r=0;r<n.length;r++){var i=n[r].toLowerCase();if(i&&e.substr(-i.length).toLowerCase()===i)return!0}return!1}(t,n)}function n(n,r,i){e.stat(n,(function(e,o){i(e,!e&&t(o,n,r))}))}return T}():function(){if(P)return G;P=1,G=t,t.sync=function(t,r){return n(e.statSync(t),r)};var e=a;function t(t,r,i){e.stat(t,(function(e,t){i(e,!e&&n(t,r))}))}function n(e,t){return e.isFile()&&function(e,t){var n=e.mode,r=e.uid,i=e.gid,o=void 0!==t.uid?t.uid:process.getuid&&process.getuid(),s=void 0!==t.gid?t.gid:process.getgid&&process.getgid(),a=parseInt("100",8),c=parseInt("010",8);return n&parseInt("001",8)||n&c&&i===s||n&a&&r===o||n&(a|c)&&0===o}(e,t)}return G}();var O=B;function B(e,t,n){if("function"==typeof t&&(n=t,t={}),!n){if("function"!=typeof Promise)throw new TypeError("callback not provided");return new Promise((function(n,r){B(e,t||{},(function(e,t){e?r(e):n(t)}))}))}A(e,t||{},(function(e,r){e&&("EACCES"===e.code||t&&t.ignoreErrors)&&(e=null,r=!1),n(e,r)}))}B.sync=function(e,t){try{return A.sync(e,t||{})}catch(e){if(t&&t.ignoreErrors||"EACCES"===e.code)return!1;throw e}};const L="win32"===process.platform||"cygwin"===process.env.OSTYPE||"msys"===process.env.OSTYPE,R=s,$=L?";":":",j=O,N=e=>Object.assign(new Error(`not found: ${e}`),{code:"ENOENT"}),U=(e,t)=>{const n=t.colon||$,r=e.match(/\//)||L&&e.match(/\\/)?[""]:[...L?[process.cwd()]:[],...(t.path||process.env.PATH||"").split(n)],i=L?t.pathExt||process.env.PATHEXT||".EXE;.CMD;.BAT;.COM":"",o=L?i.split(n):[""];return L&&-1!==e.indexOf(".")&&""!==o[0]&&o.unshift(""),{pathEnv:r,pathExt:o,pathExtExe:i}},_=(e,t,n)=>{"function"==typeof t&&(n=t,t={}),t||(t={});const{pathEnv:r,pathExt:i,pathExtExe:o}=U(e,t),s=[],a=n=>new Promise(((i,o)=>{if(n===r.length)return t.all&&s.length?i(s):o(N(e));const a=r[n],d=/^".*"$/.test(a)?a.slice(1,-1):a,u=R.join(d,e),l=!d&&/^\.[\\\/]/.test(e)?e.slice(0,2)+u:u;i(c(l,n,0))})),c=(e,n,r)=>new Promise(((d,u)=>{if(r===i.length)return d(a(n+1));const l=i[r];j(e+l,{pathExt:o},((i,o)=>{if(!i&&o){if(!t.all)return d(e+l);s.push(e+l)}return d(c(e,n,r+1))}))}));return n?a(0).then((e=>n(null,e)),n):a(0)};var D=_;_.sync=(e,t)=>{t=t||{};const{pathEnv:n,pathExt:r,pathExtExe:i}=U(e,t),o=[];for(let s=0;s<n.length;s++){const a=n[s],c=/^".*"$/.test(a)?a.slice(1,-1):a,d=R.join(c,e),u=!c&&/^\.[\\\/]/.test(e)?e.slice(0,2)+d:d;for(let e=0;e<r.length;e++){const n=u+r[e];try{if(j.sync(n,{pathExt:i})){if(!t.all)return n;o.push(n)}}catch(e){}}}if(t.all&&o.length)return o;if(t.nothrow)return null;throw N(e)};var F={exports:{}};const M=(e={})=>{const t=e.env||process.env;return"win32"!==(e.platform||process.platform)?"PATH":Object.keys(t).reverse().find((e=>"PATH"===e.toUpperCase()))||"Path"};F.exports=M,F.exports.default=M;var H=F.exports;const K=s,z=D,V=H;function W(e,t){const n=e.options.env||process.env,r=process.cwd(),i=null!=e.options.cwd,o=i&&void 0!==process.chdir&&!process.chdir.disabled;if(o)try{process.chdir(e.options.cwd)}catch(e){}let s;try{s=z.sync(e.command,{path:n[V({env:n})],pathExt:t?K.delimiter:void 0})}catch(e){}finally{o&&process.chdir(r)}return s&&(s=K.resolve(i?e.options.cwd:"",s)),s}var X=function(e){return W(e)||W(e,!0)},Y={};const q=/([()\][%!^"`<>&|;, *?])/g;Y.command=function(e){return e=e.replace(q,"^$1")},Y.argument=function(e,t){return e=(e=`"${e=(e=(e=`${e}`).replace(/(\\*)"/g,'$1$1\\"')).replace(/(\\*)$/,"$1$1")}"`).replace(q,"^$1"),t&&(e=e.replace(q,"^$1")),e};const Z=/^#!(.*)/;const Q=a,J=(e="")=>{const t=e.match(Z);if(!t)return null;const[n,r]=t[0].replace(/#! ?/,"").split(" "),i=n.split("/").pop();return"env"===i?r:r?`${i} ${r}`:i};const ee=s,te=X,ne=Y,re=function(e){const t=Buffer.alloc(150);let n;try{n=Q.openSync(e,"r"),Q.readSync(n,t,0,150,0),Q.closeSync(n)}catch(e){}return J(t.toString())},ie="win32"===process.platform,oe=/\.(?:com|exe)$/i,se=/node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;function ae(e){if(!ie)return e;const t=function(e){e.file=te(e);const t=e.file&&re(e.file);return t?(e.args.unshift(e.file),e.command=t,te(e)):e.file}(e),n=!oe.test(t);if(e.options.forceShell||n){const n=se.test(t);e.command=ee.normalize(e.command),e.command=ne.command(e.command),e.args=e.args.map((e=>ne.argument(e,n)));const r=[e.command].concat(e.args).join(" ");e.args=["/d","/s","/c",`"${r}"`],e.command=process.env.comspec||"cmd.exe",e.options.windowsVerbatimArguments=!0}return e}var ce=function(e,t,n){t&&!Array.isArray(t)&&(n=t,t=null);const r={command:e,args:t=t?t.slice(0):[],options:n=Object.assign({},n),file:void 0,original:{command:e,args:t}};return n.shell?r:ae(r)};const de="win32"===process.platform;function ue(e,t){return Object.assign(new Error(`${t} ${e.command} ENOENT`),{code:"ENOENT",errno:"ENOENT",syscall:`${t} ${e.command}`,path:e.command,spawnargs:e.args})}function le(e,t){return de&&1===e&&!t.file?ue(t.original,"spawn"):null}var pe={hookChildProcess:function(e,t){if(!de)return;const n=e.emit;e.emit=function(r,i){if("exit"===r){const r=le(i,t);if(r)return n.call(e,"error",r)}return n.apply(e,arguments)}},verifyENOENT:le,verifyENOENTSync:function(e,t){return de&&1===e&&!t.file?ue(t.original,"spawnSync"):null},notFoundError:ue};const me=o,fe=ce,he=pe;function ge(e,t,n){const r=fe(e,t,n),i=me.spawn(r.command,r.args,r.options);return he.hookChildProcess(i,r),i}k.exports=ge,k.exports.spawn=ge,k.exports.sync=function(e,t,n){const r=fe(e,t,n),i=me.spawnSync(r.command,r.args,r.options);return i.error=i.error||he.verifyENOENTSync(i.status,r),i},k.exports._parse=fe,k.exports._enoent=he;var be=E(k.exports);function ye(e){const t="string"==typeof e?"\n":"\n".charCodeAt(),n="string"==typeof e?"\r":"\r".charCodeAt();return e[e.length-1]===t&&(e=e.slice(0,-1)),e[e.length-1]===n&&(e=e.slice(0,-1)),e}function we(e={}){const{env:t=process.env,platform:n=process.platform}=e;return"win32"!==n?"PATH":Object.keys(t).reverse().find((e=>"PATH"===e.toUpperCase()))||"Path"}function xe({env:t=e.env,...r}={}){const i=we({env:t={...t}});return r.path=t[i],t[i]=function(t={}){const{cwd:r=e.cwd(),path:i=e.env[we()],execPath:o=e.execPath}=t;let s;const a=o instanceof URL?c.fileURLToPath(o):o,d=r instanceof URL?c.fileURLToPath(r):r;let u=n.resolve(d);const l=[];for(;s!==u;)l.push(n.join(u,"node_modules/.bin")),s=u,u=n.resolve(u,"..");return l.push(n.resolve(d,a,"..")),[...l,i].join(n.delimiter)}(r),t}const Se=(e,t,n,r)=>{if("length"===n||"prototype"===n)return;if("arguments"===n||"caller"===n)return;const i=Object.getOwnPropertyDescriptor(e,n),o=Object.getOwnPropertyDescriptor(t,n);!Ie(i,o)&&r||Object.defineProperty(e,n,o)},Ie=function(e,t){return void 0===e||e.configurable||e.writable===t.writable&&e.enumerable===t.enumerable&&e.configurable===t.configurable&&(e.writable||e.value===t.value)},ve=(e,t)=>`/* Wrapped ${e}*/\n${t}`,Ee=Object.getOwnPropertyDescriptor(Function.prototype,"toString"),Te=Object.getOwnPropertyDescriptor(Function.prototype.toString,"name");function Ce(e,t,{ignoreNonConfigurable:n=!1}={}){const{name:r}=e;for(const r of Reflect.ownKeys(t))Se(e,t,r,n);return((e,t)=>{const n=Object.getPrototypeOf(t);n!==Object.getPrototypeOf(e)&&Object.setPrototypeOf(e,n)})(e,t),((e,t,n)=>{const r=""===n?"":`with ${n.trim()}() `,i=ve.bind(null,r,t.toString());Object.defineProperty(i,"name",Te),Object.defineProperty(e,"toString",{...Ee,value:i})})(e,t,r),e}const Ge=new WeakMap,Pe=(e,t={})=>{if("function"!=typeof e)throw new TypeError("Expected a function");let n,r=0;const i=e.displayName||e.name||"<anonymous>",o=function(...s){if(Ge.set(o,++r),1===r)n=e.apply(this,s),e=null;else if(!0===t.throw)throw new Error(`Function \`${i}\` can only be called once`);return n};return Ce(o,e),Ge.set(o,r),o};Pe.callCount=e=>{if(!Ge.has(e))throw new Error(`The given function \`${e.name}\` is not wrapped by the \`onetime\` package`);return Ge.get(e)};const Ae=function(e,t){return{name:`SIGRT${t+1}`,number:ke+t,action:"terminate",description:"Application-specific signal (realtime)",standard:"posix"}},ke=34,Oe=64,Be=[{name:"SIGHUP",number:1,action:"terminate",description:"Terminal closed",standard:"posix"},{name:"SIGINT",number:2,action:"terminate",description:"User interruption with CTRL-C",standard:"ansi"},{name:"SIGQUIT",number:3,action:"core",description:"User interruption with CTRL-\\",standard:"posix"},{name:"SIGILL",number:4,action:"core",description:"Invalid machine instruction",standard:"ansi"},{name:"SIGTRAP",number:5,action:"core",description:"Debugger breakpoint",standard:"posix"},{name:"SIGABRT",number:6,action:"core",description:"Aborted",standard:"ansi"},{name:"SIGIOT",number:6,action:"core",description:"Aborted",standard:"bsd"},{name:"SIGBUS",number:7,action:"core",description:"Bus error due to misaligned, non-existing address or paging error",standard:"bsd"},{name:"SIGEMT",number:7,action:"terminate",description:"Command should be emulated but is not implemented",standard:"other"},{name:"SIGFPE",number:8,action:"core",description:"Floating point arithmetic error",standard:"ansi"},{name:"SIGKILL",number:9,action:"terminate",description:"Forced termination",standard:"posix",forced:!0},{name:"SIGUSR1",number:10,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGSEGV",number:11,action:"core",description:"Segmentation fault",standard:"ansi"},{name:"SIGUSR2",number:12,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGPIPE",number:13,action:"terminate",description:"Broken pipe or socket",standard:"posix"},{name:"SIGALRM",number:14,action:"terminate",description:"Timeout or timer",standard:"posix"},{name:"SIGTERM",number:15,action:"terminate",description:"Termination",standard:"ansi"},{name:"SIGSTKFLT",number:16,action:"terminate",description:"Stack is empty or overflowed",standard:"other"},{name:"SIGCHLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"posix"},{name:"SIGCLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"other"},{name:"SIGCONT",number:18,action:"unpause",description:"Unpaused",standard:"posix",forced:!0},{name:"SIGSTOP",number:19,action:"pause",description:"Paused",standard:"posix",forced:!0},{name:"SIGTSTP",number:20,action:"pause",description:'Paused using CTRL-Z or "suspend"',standard:"posix"},{name:"SIGTTIN",number:21,action:"pause",description:"Background process cannot read terminal input",standard:"posix"},{name:"SIGBREAK",number:21,action:"terminate",description:"User interruption with CTRL-BREAK",standard:"other"},{name:"SIGTTOU",number:22,action:"pause",description:"Background process cannot write to terminal output",standard:"posix"},{name:"SIGURG",number:23,action:"ignore",description:"Socket received out-of-band data",standard:"bsd"},{name:"SIGXCPU",number:24,action:"core",description:"Process timed out",standard:"bsd"},{name:"SIGXFSZ",number:25,action:"core",description:"File too big",standard:"bsd"},{name:"SIGVTALRM",number:26,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGPROF",number:27,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGWINCH",number:28,action:"ignore",description:"Terminal window size changed",standard:"bsd"},{name:"SIGIO",number:29,action:"terminate",description:"I/O is available",standard:"other"},{name:"SIGPOLL",number:29,action:"terminate",description:"Watched event",standard:"other"},{name:"SIGINFO",number:29,action:"ignore",description:"Request for process information",standard:"other"},{name:"SIGPWR",number:30,action:"terminate",description:"Device running out of power",standard:"systemv"},{name:"SIGSYS",number:31,action:"core",description:"Invalid system call",standard:"other"},{name:"SIGUNUSED",number:31,action:"terminate",description:"Invalid system call",standard:"other"}],Le=function(){const e=function(){const e=Oe-ke+1;return Array.from({length:e},Ae)}();return[...Be,...e].map(Re)},Re=function({name:e,number:t,description:n,action:r,forced:i=!1,standard:o}){const{signals:{[e]:s}}=u,a=void 0!==s;return{name:e,number:a?s:t,description:n,supported:a,action:r,forced:i,standard:o}},$e=function(e,{name:t,number:n,description:r,supported:i,action:o,forced:s,standard:a}){return{...e,[t]:{name:t,number:n,description:r,supported:i,action:o,forced:s,standard:a}}},je=Le().reduce($e,{}),Ne=function(e,t){const n=Ue(e,t);if(void 0===n)return{};const{name:r,description:i,supported:o,action:s,forced:a,standard:c}=n;return{[e]:{name:r,number:e,description:i,supported:o,action:s,forced:a,standard:c}}},Ue=function(e,t){const n=t.find((({name:t})=>u.signals[t]===e));return void 0!==n?n:t.find((t=>t.number===e))};!function(){const e=Le(),t=Oe+1,n=Array.from({length:t},((t,n)=>Ne(n,e)));Object.assign({},...n)}();const _e=({stdout:e,stderr:t,all:n,error:r,signal:i,exitCode:o,command:s,escapedCommand:a,timedOut:c,isCanceled:d,killed:u,parsed:{options:{timeout:l}}})=>{o=null===o?void 0:o;const p=void 0===(i=null===i?void 0:i)?void 0:je[i].description,m=(({timedOut:e,timeout:t,errorCode:n,signal:r,signalDescription:i,exitCode:o,isCanceled:s})=>e?`timed out after ${t} milliseconds`:s?"was canceled":void 0!==n?`failed with ${n}`:void 0!==r?`was killed with ${r} (${i})`:void 0!==o?`failed with exit code ${o}`:"failed")({timedOut:c,timeout:l,errorCode:r&&r.code,signal:i,signalDescription:p,exitCode:o,isCanceled:d}),f=`Command ${m}: ${s}`,h="[object Error]"===Object.prototype.toString.call(r),g=h?`${f}\n${r.message}`:f,b=[g,t,e].filter(Boolean).join("\n");return h?(r.originalMessage=r.message,r.message=b):r=new Error(b),r.shortMessage=g,r.command=s,r.escapedCommand=a,r.exitCode=o,r.signal=i,r.signalDescription=p,r.stdout=e,r.stderr=t,void 0!==n&&(r.all=n),"bufferedData"in r&&delete r.bufferedData,r.failed=!0,r.timedOut=Boolean(c),r.isCanceled=d,r.killed=u&&!c,r},De=["stdin","stdout","stderr"],Fe=e=>{if(!e)return;const{stdio:t}=e;if(void 0===t)return De.map((t=>e[t]));if((e=>De.some((t=>void 0!==e[t])))(e))throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${De.map((e=>`\`${e}\``)).join(", ")}`);if("string"==typeof t)return t;if(!Array.isArray(t))throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof t}\``);const n=Math.max(t.length,De.length);return Array.from({length:n},((e,n)=>t[n]))};var Me,He={exports:{}},Ke={exports:{}};var ze=v.process;const Ve=function(e){return e&&"object"==typeof e&&"function"==typeof e.removeListener&&"function"==typeof e.emit&&"function"==typeof e.reallyExit&&"function"==typeof e.listeners&&"function"==typeof e.kill&&"number"==typeof e.pid&&"function"==typeof e.on};if(Ve(ze)){var We,Xe=m,Ye=(Me||(Me=1,(at=Ke).exports=["SIGABRT","SIGALRM","SIGHUP","SIGINT","SIGTERM"],"win32"!==process.platform&&at.exports.push("SIGVTALRM","SIGXCPU","SIGXFSZ","SIGUSR2","SIGTRAP","SIGSYS","SIGQUIT","SIGIOT"),"linux"===process.platform&&at.exports.push("SIGIO","SIGPOLL","SIGPWR","SIGSTKFLT","SIGUNUSED")),Ke.exports),qe=/^win/i.test(ze.platform),Ze=f;"function"!=typeof Ze&&(Ze=Ze.EventEmitter),ze.__signal_exit_emitter__?We=ze.__signal_exit_emitter__:((We=ze.__signal_exit_emitter__=new Ze).count=0,We.emitted={}),We.infinite||(We.setMaxListeners(1/0),We.infinite=!0),He.exports=function(e,t){if(!Ve(v.process))return function(){};Xe.equal(typeof e,"function","a callback must be provided for exit handler"),!1===tt&&nt();var n="exit";t&&t.alwaysLast&&(n="afterexit");return We.on(n,e),function(){We.removeListener(n,e),0===We.listeners("exit").length&&0===We.listeners("afterexit").length&&Qe()}};var Qe=function(){tt&&Ve(v.process)&&(tt=!1,Ye.forEach((function(e){try{ze.removeListener(e,et[e])}catch(e){}})),ze.emit=ot,ze.reallyExit=rt,We.count-=1)};He.exports.unload=Qe;var Je=function(e,t,n){We.emitted[e]||(We.emitted[e]=!0,We.emit(e,t,n))},et={};Ye.forEach((function(e){et[e]=function(){Ve(v.process)&&(ze.listeners(e).length===We.count&&(Qe(),Je("exit",null,e),Je("afterexit",null,e),qe&&"SIGHUP"===e&&(e="SIGINT"),ze.kill(ze.pid,e)))}})),He.exports.signals=function(){return Ye};var tt=!1,nt=function(){!tt&&Ve(v.process)&&(tt=!0,We.count+=1,Ye=Ye.filter((function(e){try{return ze.on(e,et[e]),!0}catch(e){return!1}})),ze.emit=st,ze.reallyExit=it)};He.exports.load=nt;var rt=ze.reallyExit,it=function(e){Ve(v.process)&&(ze.exitCode=e||0,Je("exit",ze.exitCode,null),Je("afterexit",ze.exitCode,null),rt.call(ze,ze.exitCode))},ot=ze.emit,st=function(e,t){if("exit"===e&&Ve(v.process)){void 0!==t&&(ze.exitCode=t);var n=ot.apply(this,arguments);return Je("exit",ze.exitCode,null),Je("afterexit",ze.exitCode,null),n}return ot.apply(this,arguments)}}else He.exports=function(){return function(){}};var at,ct=E(He.exports);const dt=(e,t="SIGTERM",n={})=>{const r=e(t);return ut(e,t,n,r),r},ut=(e,t,n,r)=>{if(!lt(t,n,r))return;const i=mt(n),o=setTimeout((()=>{e("SIGKILL")}),i);o.unref&&o.unref()},lt=(e,{forceKillAfterTimeout:t},n)=>pt(e)&&!1!==t&&n,pt=e=>e===l.constants.signals.SIGTERM||"string"==typeof e&&"SIGTERM"===e.toUpperCase(),mt=({forceKillAfterTimeout:e=!0})=>{if(!0===e)return 5e3;if(!Number.isFinite(e)||e<0)throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`);return e},ft=(e,t)=>{e.kill()&&(t.isCanceled=!0)},ht=(e,{timeout:t,killSignal:n="SIGTERM"},r)=>{if(0===t||void 0===t)return r;let i;const o=new Promise(((r,o)=>{i=setTimeout((()=>{((e,t,n)=>{e.kill(t),n(Object.assign(new Error("Timed out"),{timedOut:!0,signal:t}))})(e,n,o)}),t)})),s=r.finally((()=>{clearTimeout(i)}));return Promise.race([o,s])},gt=({timeout:e})=>{if(void 0!==e&&(!Number.isFinite(e)||e<0))throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`)},bt=async(e,{cleanup:t,detached:n},r)=>{if(!t||n)return r;const i=ct((()=>{e.kill()}));return r.finally((()=>{i()}))};function yt(e){return null!==e&&"object"==typeof e&&"function"==typeof e.pipe}function wt(e){return yt(e)&&!1!==e.writable&&"function"==typeof e._write&&"object"==typeof e._writableState}var xt={exports:{}};const{PassThrough:St}=g;const{constants:It}=h,vt=g,{promisify:Et}=b,Tt=e=>{e={...e};const{array:t}=e;let{encoding:n}=e;const r="buffer"===n;let i=!1;t?i=!(n||r):n=n||"utf8",r&&(n=null);const o=new St({objectMode:i});n&&o.setEncoding(n);let s=0;const a=[];return o.on("data",(e=>{a.push(e),i?s=a.length:s+=e.length})),o.getBufferedValue=()=>t?a:r?Buffer.concat(a,s):a.join(""),o.getBufferedLength=()=>s,o},Ct=Et(vt.pipeline);let Gt=class extends Error{constructor(){super("maxBuffer exceeded"),this.name="MaxBufferError"}};async function Pt(e,t){if(!e)throw new Error("Expected a stream");t={maxBuffer:1/0,...t};const{maxBuffer:n}=t,r=Tt(t);return await new Promise(((t,i)=>{const o=e=>{e&&r.getBufferedLength()<=It.MAX_LENGTH&&(e.bufferedData=r.getBufferedValue()),i(e)};(async()=>{try{await Ct(e,r),t()}catch(e){o(e)}})(),r.on("data",(()=>{r.getBufferedLength()>n&&o(new Gt)}))})),r.getBufferedValue()}xt.exports=Pt,xt.exports.buffer=(e,t)=>Pt(e,{...t,encoding:"buffer"}),xt.exports.array=(e,t)=>Pt(e,{...t,array:!0}),xt.exports.MaxBufferError=Gt;var At=E(xt.exports);const{PassThrough:kt}=g;var Ot=E((function(){var e=[],t=new kt({objectMode:!0});return t.setMaxListeners(0),t.add=n,t.isEmpty=function(){return 0==e.length},t.on("unpipe",r),Array.prototype.slice.call(arguments).forEach(n),t;function n(i){return Array.isArray(i)?(i.forEach(n),this):(e.push(i),i.once("end",r.bind(null,i)),i.once("error",t.emit.bind(t,"error")),i.pipe(t,{end:!1}),this)}function r(n){!(e=e.filter((function(e){return e!==n}))).length&&t.readable&&t.end()}}));const Bt=(e,t)=>{void 0!==t&&void 0!==e.stdin&&(yt(t)?t.pipe(e.stdin):e.stdin.end(t))},Lt=(e,{all:t})=>{if(!t||!e.stdout&&!e.stderr)return;const n=Ot();return e.stdout&&n.add(e.stdout),e.stderr&&n.add(e.stderr),n},Rt=async(e,t)=>{if(e){e.destroy();try{return await t}catch(e){return e.bufferedData}}},$t=(e,{encoding:t,buffer:n,maxBuffer:r})=>{if(e&&n)return t?At(e,{encoding:t,maxBuffer:r}):At.buffer(e,{maxBuffer:r})},jt=async({stdout:e,stderr:t,all:n},{encoding:r,buffer:i,maxBuffer:o},s)=>{const a=$t(e,{encoding:r,buffer:i,maxBuffer:o}),c=$t(t,{encoding:r,buffer:i,maxBuffer:o}),d=$t(n,{encoding:r,buffer:i,maxBuffer:2*o});try{return await Promise.all([s,a,c,d])}catch(r){return Promise.all([{error:r,signal:r.signal,timedOut:r.timedOut},Rt(e,a),Rt(t,c),Rt(n,d)])}},Nt=(async()=>{})().constructor.prototype,Ut=["then","catch","finally"].map((e=>[e,Reflect.getOwnPropertyDescriptor(Nt,e)])),_t=(e,t)=>{for(const[n,r]of Ut){const i="function"==typeof t?(...e)=>Reflect.apply(r.value,t(),e):r.value.bind(t);Reflect.defineProperty(e,n,{...r,value:i})}return e},Dt=e=>new Promise(((t,n)=>{e.on("exit",((e,n)=>{t({exitCode:e,signal:n})})),e.on("error",(e=>{n(e)})),e.stdin&&e.stdin.on("error",(e=>{n(e)}))})),Ft=(e,t=[])=>Array.isArray(t)?[e,...t]:[e],Mt=/^[\w.-]+$/,Ht=/"/g,Kt=(e,t)=>Ft(e,t).join(" "),zt=(e,t)=>Ft(e,t).map((e=>(e=>"string"!=typeof e||Mt.test(e)?e:`"${e.replace(Ht,'\\"')}"`)(e))).join(" "),Vt=(t,r,i={})=>{const o=be._parse(t,r,i);return t=o.command,r=o.args,(i={maxBuffer:1e8,buffer:!0,stripFinalNewline:!0,extendEnv:!0,preferLocal:!1,localDir:(i=o.options).cwd||e.cwd(),execPath:e.execPath,encoding:"utf8",reject:!0,cleanup:!0,all:!1,windowsHide:!0,...i}).env=(({env:t,extendEnv:n,preferLocal:r,localDir:i,execPath:o})=>{const s=n?{...e.env,...t}:t;return r?xe({env:s,cwd:i,execPath:o}):s})(i),i.stdio=Fe(i),"win32"===e.platform&&"cmd"===n.basename(t,".exe")&&r.unshift("/q"),{file:t,args:r,options:i,parsed:o}},Wt=(e,n,r)=>"string"==typeof n||t.isBuffer(n)?e.stripFinalNewline?ye(n):n:void 0===r?void 0:"";async function Xt(t,n={}){await function(e,t,n){const i=Vt(e,t,n),o=Kt(e,t),s=zt(e,t);let a;gt(i.options);try{a=r.spawn(i.file,i.args,i.options)}catch(e){const t=new r.ChildProcess,n=Promise.reject(_e({error:e,stdout:"",stderr:"",all:"",command:o,escapedCommand:s,parsed:i,timedOut:!1,isCanceled:!1,killed:!1}));return _t(t,n)}const c=Dt(a),d=ht(a,i.options,c),u=bt(a,i.options,d);a.kill=dt.bind(null,a.kill.bind(a)),a.cancel=ft.bind(null,a,{isCanceled:!1});const l=Pe((async()=>{const[{error:e,exitCode:t,signal:n,timedOut:r},c,d,l]=await jt(a,i.options,u),p=Wt(i.options,c),m=Wt(i.options,d),f=Wt(i.options,l);if(e||0!==t||null!==n){const c=_e({error:e,exitCode:t,signal:n,stdout:p,stderr:m,all:f,command:o,escapedCommand:s,parsed:i,timedOut:r,isCanceled:!!i.options.signal&&i.options.signal.aborted,killed:a.killed});if(!i.options.reject)return c;throw c}return{command:o,escapedCommand:s,exitCode:0,stdout:p,stderr:m,all:f,failed:!1,timedOut:!1,isCanceled:!1,killed:!1}}));return Bt(a,i.options.input),a.all=Lt(a,i.options),_t(a,l)}("taskkill",function(t,n){if("win32"!==e.platform)throw new Error("Windows only");if(0===(t=[t].flat()).length)throw new Error("PID or image name required");const r=[];n.system&&n.username&&n.password&&r.push("/s",n.system,"/u",n.username,"/p",n.password),n.filter&&r.push("/fi",n.filter),n.force&&r.push("/f"),n.tree&&r.push("/t");for(const e of t)r.push("number"==typeof e?"/pid":"/im",e);return r}(t,n))}const Yt=(e,t)=>({name:`SIGRT${t+1}`,number:qt+t,action:"terminate",description:"Application-specific signal (realtime)",standard:"posix"}),qt=34,Zt=64,Qt=[{name:"SIGHUP",number:1,action:"terminate",description:"Terminal closed",standard:"posix"},{name:"SIGINT",number:2,action:"terminate",description:"User interruption with CTRL-C",standard:"ansi"},{name:"SIGQUIT",number:3,action:"core",description:"User interruption with CTRL-\\",standard:"posix"},{name:"SIGILL",number:4,action:"core",description:"Invalid machine instruction",standard:"ansi"},{name:"SIGTRAP",number:5,action:"core",description:"Debugger breakpoint",standard:"posix"},{name:"SIGABRT",number:6,action:"core",description:"Aborted",standard:"ansi"},{name:"SIGIOT",number:6,action:"core",description:"Aborted",standard:"bsd"},{name:"SIGBUS",number:7,action:"core",description:"Bus error due to misaligned, non-existing address or paging error",standard:"bsd"},{name:"SIGEMT",number:7,action:"terminate",description:"Command should be emulated but is not implemented",standard:"other"},{name:"SIGFPE",number:8,action:"core",description:"Floating point arithmetic error",standard:"ansi"},{name:"SIGKILL",number:9,action:"terminate",description:"Forced termination",standard:"posix",forced:!0},{name:"SIGUSR1",number:10,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGSEGV",number:11,action:"core",description:"Segmentation fault",standard:"ansi"},{name:"SIGUSR2",number:12,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGPIPE",number:13,action:"terminate",description:"Broken pipe or socket",standard:"posix"},{name:"SIGALRM",number:14,action:"terminate",description:"Timeout or timer",standard:"posix"},{name:"SIGTERM",number:15,action:"terminate",description:"Termination",standard:"ansi"},{name:"SIGSTKFLT",number:16,action:"terminate",description:"Stack is empty or overflowed",standard:"other"},{name:"SIGCHLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"posix"},{name:"SIGCLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"other"},{name:"SIGCONT",number:18,action:"unpause",description:"Unpaused",standard:"posix",forced:!0},{name:"SIGSTOP",number:19,action:"pause",description:"Paused",standard:"posix",forced:!0},{name:"SIGTSTP",number:20,action:"pause",description:'Paused using CTRL-Z or "suspend"',standard:"posix"},{name:"SIGTTIN",number:21,action:"pause",description:"Background process cannot read terminal input",standard:"posix"},{name:"SIGBREAK",number:21,action:"terminate",description:"User interruption with CTRL-BREAK",standard:"other"},{name:"SIGTTOU",number:22,action:"pause",description:"Background process cannot write to terminal output",standard:"posix"},{name:"SIGURG",number:23,action:"ignore",description:"Socket received out-of-band data",standard:"bsd"},{name:"SIGXCPU",number:24,action:"core",description:"Process timed out",standard:"bsd"},{name:"SIGXFSZ",number:25,action:"core",description:"File too big",standard:"bsd"},{name:"SIGVTALRM",number:26,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGPROF",number:27,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGWINCH",number:28,action:"ignore",description:"Terminal window size changed",standard:"bsd"},{name:"SIGIO",number:29,action:"terminate",description:"I/O is available",standard:"other"},{name:"SIGPOLL",number:29,action:"terminate",description:"Watched event",standard:"other"},{name:"SIGINFO",number:29,action:"ignore",description:"Request for process information",standard:"other"},{name:"SIGPWR",number:30,action:"terminate",description:"Device running out of power",standard:"systemv"},{name:"SIGSYS",number:31,action:"core",description:"Invalid system call",standard:"other"},{name:"SIGUNUSED",number:31,action:"terminate",description:"Invalid system call",standard:"other"}],Jt=()=>{const e=(()=>{const e=Zt-qt+1;return Array.from({length:e},Yt)})();return[...Qt,...e].map(en)},en=({name:e,number:t,description:n,action:r,forced:i=!1,standard:o})=>{const{signals:{[e]:s}}=p,a=void 0!==s;return{name:e,number:a?s:t,description:n,supported:a,action:r,forced:i,standard:o}},tn=({name:e,number:t,description:n,supported:r,action:i,forced:o,standard:s})=>[e,{name:e,number:t,description:n,supported:r,action:i,forced:o,standard:s}],nn=(()=>{const e=Jt();return Object.fromEntries(e.map(tn))})(),rn=(e,t)=>{const n=on(e,t);if(void 0===n)return{};const{name:r,description:i,supported:o,action:s,forced:a,standard:c}=n;return{[e]:{name:r,number:e,description:i,supported:o,action:s,forced:a,standard:c}}},on=(e,t)=>{const n=t.find((({name:t})=>p.signals[t]===e));return void 0!==n?n:t.find((t=>t.number===e))};(()=>{const e=Jt(),t=Zt+1,n=Array.from({length:t},((t,n)=>rn(n,e)));Object.assign({},...n)})();const sn=({stdout:t,stderr:n,all:r,error:i,signal:o,exitCode:s,command:a,escapedCommand:c,timedOut:d,isCanceled:u,killed:l,parsed:{options:{timeout:p,cwd:m=e.cwd()}}})=>{s=null===s?void 0:s;const f=void 0===(o=null===o?void 0:o)?void 0:nn[o].description,h=(({timedOut:e,timeout:t,errorCode:n,signal:r,signalDescription:i,exitCode:o,isCanceled:s})=>e?`timed out after ${t} milliseconds`:s?"was canceled":void 0!==n?`failed with ${n}`:void 0!==r?`was killed with ${r} (${i})`:void 0!==o?`failed with exit code ${o}`:"failed")({timedOut:d,timeout:p,errorCode:i&&i.code,signal:o,signalDescription:f,exitCode:s,isCanceled:u}),g=`Command ${h}: ${a}`,b="[object Error]"===Object.prototype.toString.call(i),y=b?`${g}\n${i.message}`:g,w=[y,n,t].filter(Boolean).join("\n");return b?(i.originalMessage=i.message,i.message=w):i=new Error(w),i.shortMessage=y,i.command=a,i.escapedCommand=c,i.exitCode=s,i.signal=o,i.signalDescription=f,i.stdout=t,i.stderr=n,i.cwd=m,void 0!==r&&(i.all=r),"bufferedData"in i&&delete i.bufferedData,i.failed=!0,i.timedOut=Boolean(d),i.isCanceled=u,i.killed=l&&!d,i},an=["stdin","stdout","stderr"],cn=e=>{if(!e)return;const{stdio:t}=e;if(void 0===t)return an.map((t=>e[t]));if((e=>an.some((t=>void 0!==e[t])))(e))throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${an.map((e=>`\`${e}\``)).join(", ")}`);if("string"==typeof t)return t;if(!Array.isArray(t))throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof t}\``);const n=Math.max(t.length,an.length);return Array.from({length:n},((e,n)=>t[n]))},dn=[];dn.push("SIGHUP","SIGINT","SIGTERM"),"win32"!==process.platform&&dn.push("SIGALRM","SIGABRT","SIGVTALRM","SIGXCPU","SIGXFSZ","SIGUSR2","SIGTRAP","SIGSYS","SIGQUIT","SIGIOT"),"linux"===process.platform&&dn.push("SIGIO","SIGPOLL","SIGPWR","SIGSTKFLT");const un=e=>!!e&&"object"==typeof e&&"function"==typeof e.removeListener&&"function"==typeof e.emit&&"function"==typeof e.reallyExit&&"function"==typeof e.listeners&&"function"==typeof e.kill&&"number"==typeof e.pid&&"function"==typeof e.on,ln=Symbol.for("signal-exit emitter"),pn=globalThis,mn=Object.defineProperty.bind(Object);let fn=class{emitted={afterExit:!1,exit:!1};listeners={afterExit:[],exit:[]};count=0;id=Math.random();constructor(){if(pn[ln])return pn[ln];mn(pn,ln,{value:this,writable:!1,enumerable:!1,configurable:!1})}on(e,t){this.listeners[e].push(t)}removeListener(e,t){const n=this.listeners[e],r=n.indexOf(t);-1!==r&&(0===r&&1===n.length?n.length=0:n.splice(r,1))}emit(e,t,n){if(this.emitted[e])return!1;this.emitted[e]=!0;let r=!1;for(const i of this.listeners[e])r=!0===i(t,n)||r;return"exit"===e&&(r=this.emit("afterExit",t,n)||r),r}},hn=class{};const gn=globalThis.process,{onExit:bn,load:yn,unload:wn}=(xn=un(gn)?new class extends hn{#e="win32"===gn.platform?"SIGINT":"SIGHUP";#t=new fn;#n;#r;#i;#o={};#s=!1;constructor(e){super(),this.#n=e,this.#o={};for(const t of dn)this.#o[t]=()=>{const n=this.#n.listeners(t);let{count:r}=this.#t;const i=e;if("object"==typeof i.__signal_exit_emitter__&&"number"==typeof i.__signal_exit_emitter__.count&&(r+=i.__signal_exit_emitter__.count),n.length===r){this.unload();const n=this.#t.emit("exit",null,t),r="SIGHUP"===t?this.#e:t;n||e.kill(e.pid,r)}};this.#i=e.reallyExit,this.#r=e.emit}onExit(e,t){if(!un(this.#n))return()=>{};!1===this.#s&&this.load();const n=t?.alwaysLast?"afterExit":"exit";return this.#t.on(n,e),()=>{this.#t.removeListener(n,e),0===this.#t.listeners.exit.length&&0===this.#t.listeners.afterExit.length&&this.unload()}}load(){if(!this.#s){this.#s=!0,this.#t.count+=1;for(const e of dn)try{const t=this.#o[e];t&&this.#n.on(e,t)}catch(e){}this.#n.emit=(e,...t)=>this.#a(e,...t),this.#n.reallyExit=e=>this.#c(e)}}unload(){this.#s&&(this.#s=!1,dn.forEach((e=>{const t=this.#o[e];if(!t)throw new Error("Listener not defined for signal: "+e);try{this.#n.removeListener(e,t)}catch(e){}})),this.#n.emit=this.#r,this.#n.reallyExit=this.#i,this.#t.count-=1)}#c(e){return un(this.#n)?(this.#n.exitCode=e||0,this.#t.emit("exit",this.#n.exitCode,null),this.#i.call(this.#n,this.#n.exitCode)):0}#a(e,...t){const n=this.#r;if("exit"===e&&un(this.#n)){"number"==typeof t[0]&&(this.#n.exitCode=t[0]);const r=n.call(this.#n,e,...t);return this.#t.emit("exit",this.#n.exitCode,null),r}return n.call(this.#n,e,...t)}}(gn):new class extends hn{onExit(){return()=>{}}load(){}unload(){}},{onExit:(e,t)=>xn.onExit(e,t),load:()=>xn.load(),unload:()=>xn.unload()});var xn;const Sn=(e,t="SIGTERM",n={})=>{const r=e(t);return In(e,t,n,r),r},In=(e,t,n,r)=>{if(!vn(t,n,r))return;const i=Tn(n),o=setTimeout((()=>{e("SIGKILL")}),i);o.unref&&o.unref()},vn=(e,{forceKillAfterTimeout:t},n)=>En(e)&&!1!==t&&n,En=e=>e===l.constants.signals.SIGTERM||"string"==typeof e&&"SIGTERM"===e.toUpperCase(),Tn=({forceKillAfterTimeout:e=!0})=>{if(!0===e)return 5e3;if(!Number.isFinite(e)||e<0)throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`);return e},Cn=(e,t)=>{e.kill()&&(t.isCanceled=!0)},Gn=(e,{timeout:t,killSignal:n="SIGTERM"},r)=>{if(0===t||void 0===t)return r;let i;const o=new Promise(((r,o)=>{i=setTimeout((()=>{((e,t,n)=>{e.kill(t),n(Object.assign(new Error("Timed out"),{timedOut:!0,signal:t}))})(e,n,o)}),t)})),s=r.finally((()=>{clearTimeout(i)}));return Promise.race([o,s])},Pn=(e,t,n)=>{if("string"==typeof n)return e[t].pipe(y(n)),e;if(wt(n))return e[t].pipe(n),e;if(!(e=>e instanceof i&&"function"==typeof e.then)(n))throw new TypeError("The second argument must be a string, a stream or an Execa child process.");if(!wt(n.stdin))throw new TypeError("The target child process's stdin must be available.");return e[t].pipe(n.stdin),n},An=async(e,{init:t,convertChunk:n,getSize:r,truncateChunk:i,addChunk:o,getFinalChunk:s,finalize:a},{maxBuffer:c=Number.POSITIVE_INFINITY}={})=>{if(!Ln(e))throw new Error("The first argument must be a Readable, a ReadableStream, or an async iterable.");const d=t();d.length=0;try{for await(const t of e){const e=n[Rn(t)](t,d);On({convertedChunk:e,state:d,getSize:r,truncateChunk:i,addChunk:o,maxBuffer:c})}return kn({state:d,convertChunk:n,getSize:r,truncateChunk:i,addChunk:o,getFinalChunk:s,maxBuffer:c}),a(d)}catch(e){throw e.bufferedData=a(d),e}},kn=({state:e,getSize:t,truncateChunk:n,addChunk:r,getFinalChunk:i,maxBuffer:o})=>{const s=i(e);void 0!==s&&On({convertedChunk:s,state:e,getSize:t,truncateChunk:n,addChunk:r,maxBuffer:o})},On=({convertedChunk:e,state:t,getSize:n,truncateChunk:r,addChunk:i,maxBuffer:o})=>{const s=n(e),a=t.length+s;if(a<=o)return void Bn(e,t,i,a);const c=r(e,o-t.length);throw void 0!==c&&Bn(c,t,i,o),new jn},Bn=(e,t,n,r)=>{t.contents=n(e,t,r),t.length=r},Ln=e=>"object"==typeof e&&null!==e&&"function"==typeof e[Symbol.asyncIterator],Rn=e=>{const t=typeof e;if("string"===t)return"string";if("object"!==t||null===e)return"others";if(globalThis.Buffer?.isBuffer(e))return"buffer";const n=$n.call(e);return"[object ArrayBuffer]"===n?"arrayBuffer":"[object DataView]"===n?"dataView":Number.isInteger(e.byteLength)&&Number.isInteger(e.byteOffset)&&"[object ArrayBuffer]"===$n.call(e.buffer)?"typedArray":"others"},{toString:$n}=Object.prototype;let jn=class extends Error{name="MaxBufferError";constructor(){super("maxBuffer exceeded")}};const Nn=e=>{throw new Error(`Streams in object mode are not supported: ${String(e)}`)},Un=e=>e.length;const _n=new TextEncoder,Dn=e=>new Uint8Array(e),Fn=e=>new Uint8Array(e.buffer,e.byteOffset,e.byteLength),Mn=(e,t)=>{if(t<=e.byteLength)return e;const n=new ArrayBuffer(Kn(t));return new Uint8Array(n).set(new Uint8Array(e),0),n},Hn=(e,t)=>{if(t<=e.maxByteLength)return e.resize(t),e;const n=new ArrayBuffer(t,{maxByteLength:Kn(t)});return new Uint8Array(n).set(new Uint8Array(e),0),n},Kn=e=>zn**Math.ceil(Math.log(e)/Math.log(zn)),zn=2,Vn=()=>"resize"in ArrayBuffer.prototype,Wn={init:()=>({contents:new ArrayBuffer(0)}),convertChunk:{string:e=>_n.encode(e),buffer:Dn,arrayBuffer:Dn,dataView:Fn,typedArray:Fn,others:Nn},getSize:Un,truncateChunk:(e,t)=>e.slice(0,t),addChunk:(e,{contents:t,length:n},r)=>{const i=Vn()?Hn(t,r):Mn(t,r);return new Uint8Array(i).set(e,n),i},getFinalChunk:()=>{},finalize:({contents:e,length:t})=>Vn()?e:e.slice(0,t)};async function Xn(e,t){if(!("Buffer"in globalThis))throw new Error("getStreamAsBuffer() is only supported in Node.js");try{return Yn(await async function(e,t){return An(e,Wn,t)}(e,t))}catch(e){throw void 0!==e.bufferedData&&(e.bufferedData=Yn(e.bufferedData)),e}}const Yn=e=>globalThis.Buffer.from(e);const qn=(e,{textDecoder:t})=>t.decode(e,{stream:!0}),Zn={init:()=>({contents:"",textDecoder:new TextDecoder}),convertChunk:{string:e=>e,buffer:qn,arrayBuffer:qn,dataView:qn,typedArray:qn,others:Nn},getSize:Un,truncateChunk:(e,t)=>e.slice(0,t),addChunk:(e,{contents:t})=>t+e,getFinalChunk:({textDecoder:e})=>{const t=e.decode();return""===t?void 0:t},finalize:({contents:e})=>e},Qn=({input:e,inputFile:t})=>"string"!=typeof t?e:((e=>{if(void 0!==e)throw new TypeError("The `input` and `inputFile` options cannot be both set.")})(e),w(t)),Jn=async(e,t)=>{if(e&&void 0!==t){await x(0),e.destroy();try{return await t}catch(e){return e.bufferedData}}},er=(e,{encoding:t,buffer:n,maxBuffer:r})=>{if(e&&n)return"utf8"===t||"utf-8"===t?async function(e,t){return An(e,Zn,t)}(e,{maxBuffer:r}):null===t||"buffer"===t?Xn(e,{maxBuffer:r}):tr(e,r,t)},tr=async(e,t,n)=>(await Xn(e,{maxBuffer:t})).toString(n),nr=(async()=>{})().constructor.prototype,rr=["then","catch","finally"].map((e=>[e,Reflect.getOwnPropertyDescriptor(nr,e)])),ir=(e,t)=>{for(const[n,r]of rr){const i="function"==typeof t?(...e)=>Reflect.apply(r.value,t(),e):r.value.bind(t);Reflect.defineProperty(e,n,{...r,value:i})}},or=(e,t=[])=>Array.isArray(t)?[e,...t]:[e],sr=/^[\w.-]+$/,ar=(e,t)=>or(e,t).map((e=>(e=>"string"!=typeof e||sr.test(e)?e:`"${e.replaceAll('"','\\"')}"`)(e))).join(" "),cr=S("execa").enabled,dr=(e,t)=>String(e).padStart(t,"0"),ur=(t,{verbose:n})=>{n&&e.stderr.write(`[${(()=>{const e=new Date;return`${dr(e.getHours(),2)}:${dr(e.getMinutes(),2)}:${dr(e.getSeconds(),2)}.${dr(e.getMilliseconds(),3)}`})()}] ${t}\n`)},lr=(t,r,i={})=>{const o=be._parse(t,r,i);return t=o.command,r=o.args,(i={maxBuffer:1e8,buffer:!0,stripFinalNewline:!0,extendEnv:!0,preferLocal:!1,localDir:(i=o.options).cwd||e.cwd(),execPath:e.execPath,encoding:"utf8",reject:!0,cleanup:!0,all:!1,windowsHide:!0,verbose:cr,...i}).env=(({env:t,extendEnv:n,preferLocal:r,localDir:i,execPath:o})=>{const s=n?{...e.env,...t}:t;return r?xe({env:s,cwd:i,execPath:o}):s})(i),i.stdio=cn(i),"win32"===e.platform&&"cmd"===n.basename(t,".exe")&&r.unshift("/q"),{file:t,args:r,options:i,parsed:o}},pr=(e,n,r)=>"string"==typeof n||t.isBuffer(n)?e.stripFinalNewline?ye(n):n:void 0===r?void 0:"";function mr(e,t,n){const i=lr(e,t,n),o=((e,t)=>or(e,t).join(" "))(e,t),s=ar(e,t);let a;ur(s,i.options),(({timeout:e})=>{if(void 0!==e&&(!Number.isFinite(e)||e<0))throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`)})(i.options);try{a=r.spawn(i.file,i.args,i.options)}catch(e){const t=new r.ChildProcess,n=Promise.reject(sn({error:e,stdout:"",stderr:"",all:"",command:o,escapedCommand:s,parsed:i,timedOut:!1,isCanceled:!1,killed:!1}));return ir(t,n),t}const c=(e=>new Promise(((t,n)=>{e.on("exit",((e,n)=>{t({exitCode:e,signal:n})})),e.on("error",(e=>{n(e)})),e.stdin&&e.stdin.on("error",(e=>{n(e)}))})))(a),d=Gn(a,i.options,c),u=(async(e,{cleanup:t,detached:n},r)=>{if(!t||n)return r;const i=bn((()=>{e.kill()}));return r.finally((()=>{i()}))})(a,i.options,d);a.kill=Sn.bind(null,a.kill.bind(a)),a.cancel=Cn.bind(null,a,{isCanceled:!1});const l=Pe((async()=>{const[{error:e,exitCode:t,signal:n,timedOut:r},c,d,l]=await(async({stdout:e,stderr:t,all:n},{encoding:r,buffer:i,maxBuffer:o},s)=>{const a=er(e,{encoding:r,buffer:i,maxBuffer:o}),c=er(t,{encoding:r,buffer:i,maxBuffer:o}),d=er(n,{encoding:r,buffer:i,maxBuffer:2*o});try{return await Promise.all([s,a,c,d])}catch(r){return Promise.all([{error:r,signal:r.signal,timedOut:r.timedOut},Jn(e,a),Jn(t,c),Jn(n,d)])}})(a,i.options,u),p=pr(i.options,c),m=pr(i.options,d),f=pr(i.options,l);if(e||0!==t||null!==n){const c=sn({error:e,exitCode:t,signal:n,stdout:p,stderr:m,all:f,command:o,escapedCommand:s,parsed:i,timedOut:r,isCanceled:!!i.options.signal&&i.options.signal.aborted,killed:a.killed});if(!i.options.reject)return c;throw c}return{command:o,escapedCommand:s,exitCode:0,stdout:p,stderr:m,all:f,failed:!1,timedOut:!1,isCanceled:!1,killed:!1}}));return((e,t)=>{const n=Qn(t);void 0!==n&&(yt(n)?n.pipe(e.stdin):e.stdin.end(n))})(a,i.options),a.all=((e,{all:t})=>{if(!t||!e.stdout&&!e.stderr)return;const n=Ot();return e.stdout&&n.add(e.stdout),e.stderr&&n.add(e.stderr),n})(a,i.options),(e=>{null!==e.stdout&&(e.pipeStdout=Pn.bind(void 0,e,"stdout")),null!==e.stderr&&(e.pipeStderr=Pn.bind(void 0,e,"stderr")),void 0!==e.all&&(e.pipeAll=Pn.bind(void 0,e,"all"))})(a),ir(a,l),a}var fr=()=>"";const hr=/\s+at.*[(\s](.*)\)?/,gr=/^(?:(?:(?:node|node:[\w/]+|(?:(?:node:)?internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)(?:\.js)?:\d+:\d+)|native)/;function br(e,{pretty:t=!1,basePath:n,pathFilter:r}={}){const i=n&&new RegExp(`(file://)?${function(e){if("string"!=typeof e)throw new TypeError("Expected a string");return e.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}(n.replace(/\\/g,"/"))}/?`,"g"),o=t?fr():"";if("string"==typeof e)return e.replace(/\\/g,"/").split("\n").filter((e=>{const t=e.match(hr);if(null===t||!t[1])return!0;const n=t[1];return!(n.includes(".app/Contents/Resources/electron.asar")||n.includes(".app/Contents/Resources/default_app.asar")||n.includes("node_modules/electron/dist/resources/electron.asar")||n.includes("node_modules/electron/dist/resources/default_app.asar"))&&(r?!gr.test(n)&&r(n):!gr.test(n))})).filter((e=>""!==e.trim())).map((e=>(i&&(e=e.replace(i,"")),t&&(e=e.replace(hr,((e,t)=>e.replace(t,t.replace(o,"~"))))),e))).join("\n")}class yr extends Error{#d;name="AggregateError";constructor(e){if(!Array.isArray(e))throw new TypeError("Expected input to be an Array, got "+typeof e);let t=(e=e.map((e=>e instanceof Error?e:null!==e&&"object"==typeof e?Object.assign(new Error(e.message),e):new Error(e)))).map((e=>"string"==typeof e.stack&&e.stack.length>0?br(e.stack).replaceAll(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g,""):String(e))).join("\n");t="\n"+function(e,t=1,n={}){const{indent:r=" ",includeEmptyLines:i=!1}=n;if("string"!=typeof e)throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if("number"!=typeof t)throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);if(t<0)throw new RangeError(`Expected \`count\` to be at least 0, got \`${t}\``);if("string"!=typeof r)throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r}\``);if(0===t)return e;const o=i?/^/gm:/^(?!\s*$)/gm;return e.replace(o,r.repeat(t))}(t,4),super(t),this.#d=e}get errors(){return[...this.#d]}}const wr=(e,t)=>({name:`SIGRT${t+1}`,number:xr+t,action:"terminate",description:"Application-specific signal (realtime)",standard:"posix"}),xr=34,Sr=64,Ir=[{name:"SIGHUP",number:1,action:"terminate",description:"Terminal closed",standard:"posix"},{name:"SIGINT",number:2,action:"terminate",description:"User interruption with CTRL-C",standard:"ansi"},{name:"SIGQUIT",number:3,action:"core",description:"User interruption with CTRL-\\",standard:"posix"},{name:"SIGILL",number:4,action:"core",description:"Invalid machine instruction",standard:"ansi"},{name:"SIGTRAP",number:5,action:"core",description:"Debugger breakpoint",standard:"posix"},{name:"SIGABRT",number:6,action:"core",description:"Aborted",standard:"ansi"},{name:"SIGIOT",number:6,action:"core",description:"Aborted",standard:"bsd"},{name:"SIGBUS",number:7,action:"core",description:"Bus error due to misaligned, non-existing address or paging error",standard:"bsd"},{name:"SIGEMT",number:7,action:"terminate",description:"Command should be emulated but is not implemented",standard:"other"},{name:"SIGFPE",number:8,action:"core",description:"Floating point arithmetic error",standard:"ansi"},{name:"SIGKILL",number:9,action:"terminate",description:"Forced termination",standard:"posix",forced:!0},{name:"SIGUSR1",number:10,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGSEGV",number:11,action:"core",description:"Segmentation fault",standard:"ansi"},{name:"SIGUSR2",number:12,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGPIPE",number:13,action:"terminate",description:"Broken pipe or socket",standard:"posix"},{name:"SIGALRM",number:14,action:"terminate",description:"Timeout or timer",standard:"posix"},{name:"SIGTERM",number:15,action:"terminate",description:"Termination",standard:"ansi"},{name:"SIGSTKFLT",number:16,action:"terminate",description:"Stack is empty or overflowed",standard:"other"},{name:"SIGCHLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"posix"},{name:"SIGCLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"other"},{name:"SIGCONT",number:18,action:"unpause",description:"Unpaused",standard:"posix",forced:!0},{name:"SIGSTOP",number:19,action:"pause",description:"Paused",standard:"posix",forced:!0},{name:"SIGTSTP",number:20,action:"pause",description:'Paused using CTRL-Z or "suspend"',standard:"posix"},{name:"SIGTTIN",number:21,action:"pause",description:"Background process cannot read terminal input",standard:"posix"},{name:"SIGBREAK",number:21,action:"terminate",description:"User interruption with CTRL-BREAK",standard:"other"},{name:"SIGTTOU",number:22,action:"pause",description:"Background process cannot write to terminal output",standard:"posix"},{name:"SIGURG",number:23,action:"ignore",description:"Socket received out-of-band data",standard:"bsd"},{name:"SIGXCPU",number:24,action:"core",description:"Process timed out",standard:"bsd"},{name:"SIGXFSZ",number:25,action:"core",description:"File too big",standard:"bsd"},{name:"SIGVTALRM",number:26,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGPROF",number:27,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGWINCH",number:28,action:"ignore",description:"Terminal window size changed",standard:"bsd"},{name:"SIGIO",number:29,action:"terminate",description:"I/O is available",standard:"other"},{name:"SIGPOLL",number:29,action:"terminate",description:"Watched event",standard:"other"},{name:"SIGINFO",number:29,action:"ignore",description:"Request for process information",standard:"other"},{name:"SIGPWR",number:30,action:"terminate",description:"Device running out of power",standard:"systemv"},{name:"SIGSYS",number:31,action:"core",description:"Invalid system call",standard:"other"},{name:"SIGUNUSED",number:31,action:"terminate",description:"Invalid system call",standard:"other"}],vr=()=>{const e=(()=>{const e=Sr-xr+1;return Array.from({length:e},wr)})();return[...Ir,...e].map(Er)},Er=({name:e,number:t,description:n,action:r,forced:i=!1,standard:o})=>{const{signals:{[e]:s}}=p,a=void 0!==s;return{name:e,number:a?s:t,description:n,supported:a,action:r,forced:i,standard:o}},Tr=({name:e,number:t,description:n,supported:r,action:i,forced:o,standard:s})=>[e,{name:e,number:t,description:n,supported:r,action:i,forced:o,standard:s}],Cr=(()=>{const e=vr();return Object.fromEntries(e.map(Tr))})(),Gr=(e,t)=>{const n=Pr(e,t);if(void 0===n)return{};const{name:r,description:i,supported:o,action:s,forced:a,standard:c}=n;return{[e]:{name:r,number:e,description:i,supported:o,action:s,forced:a,standard:c}}},Pr=(e,t)=>{const n=t.find((({name:t})=>p.signals[t]===e));return void 0!==n?n:t.find((t=>t.number===e))};(()=>{const e=vr(),t=Sr+1,n=Array.from({length:t},((t,n)=>Gr(n,e)));Object.assign({},...n)})();const Ar=({stdout:t,stderr:n,all:r,error:i,signal:o,exitCode:s,command:a,escapedCommand:c,timedOut:d,isCanceled:u,killed:l,parsed:{options:{timeout:p,cwd:m=e.cwd()}}})=>{s=null===s?void 0:s;const f=void 0===(o=null===o?void 0:o)?void 0:Cr[o].description,h=(({timedOut:e,timeout:t,errorCode:n,signal:r,signalDescription:i,exitCode:o,isCanceled:s})=>e?`timed out after ${t} milliseconds`:s?"was canceled":void 0!==n?`failed with ${n}`:void 0!==r?`was killed with ${r} (${i})`:void 0!==o?`failed with exit code ${o}`:"failed")({timedOut:d,timeout:p,errorCode:i&&i.code,signal:o,signalDescription:f,exitCode:s,isCanceled:u}),g=`Command ${h}: ${a}`,b="[object Error]"===Object.prototype.toString.call(i),y=b?`${g}\n${i.message}`:g,w=[y,n,t].filter(Boolean).join("\n");return b?(i.originalMessage=i.message,i.message=w):i=new Error(w),i.shortMessage=y,i.command=a,i.escapedCommand=c,i.exitCode=s,i.signal=o,i.signalDescription=f,i.stdout=t,i.stderr=n,i.cwd=m,void 0!==r&&(i.all=r),"bufferedData"in i&&delete i.bufferedData,i.failed=!0,i.timedOut=Boolean(d),i.isCanceled=u,i.killed=l&&!d,i},kr=["stdin","stdout","stderr"],Or=e=>{if(!e)return;const{stdio:t}=e;if(void 0===t)return kr.map((t=>e[t]));if((e=>kr.some((t=>void 0!==e[t])))(e))throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${kr.map((e=>`\`${e}\``)).join(", ")}`);if("string"==typeof t)return t;if(!Array.isArray(t))throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof t}\``);const n=Math.max(t.length,kr.length);return Array.from({length:n},((e,n)=>t[n]))},Br=[];Br.push("SIGHUP","SIGINT","SIGTERM"),"win32"!==process.platform&&Br.push("SIGALRM","SIGABRT","SIGVTALRM","SIGXCPU","SIGXFSZ","SIGUSR2","SIGTRAP","SIGSYS","SIGQUIT","SIGIOT"),"linux"===process.platform&&Br.push("SIGIO","SIGPOLL","SIGPWR","SIGSTKFLT");const Lr=e=>!!e&&"object"==typeof e&&"function"==typeof e.removeListener&&"function"==typeof e.emit&&"function"==typeof e.reallyExit&&"function"==typeof e.listeners&&"function"==typeof e.kill&&"number"==typeof e.pid&&"function"==typeof e.on,Rr=Symbol.for("signal-exit emitter"),$r=globalThis,jr=Object.defineProperty.bind(Object);class Nr{emitted={afterExit:!1,exit:!1};listeners={afterExit:[],exit:[]};count=0;id=Math.random();constructor(){if($r[Rr])return $r[Rr];jr($r,Rr,{value:this,writable:!1,enumerable:!1,configurable:!1})}on(e,t){this.listeners[e].push(t)}removeListener(e,t){const n=this.listeners[e],r=n.indexOf(t);-1!==r&&(0===r&&1===n.length?n.length=0:n.splice(r,1))}emit(e,t,n){if(this.emitted[e])return!1;this.emitted[e]=!0;let r=!1;for(const i of this.listeners[e])r=!0===i(t,n)||r;return"exit"===e&&(r=this.emit("afterExit",t,n)||r),r}}class Ur{}const _r=globalThis.process,{onExit:Dr,load:Fr,unload:Mr}=(e=>({onExit:(t,n)=>e.onExit(t,n),load:()=>e.load(),unload:()=>e.unload()}))(Lr(_r)?new class extends Ur{#e="win32"===_r.platform?"SIGINT":"SIGHUP";#t=new Nr;#n;#r;#i;#o={};#s=!1;constructor(e){super(),this.#n=e,this.#o={};for(const t of Br)this.#o[t]=()=>{const n=this.#n.listeners(t);let{count:r}=this.#t;const i=e;if("object"==typeof i.__signal_exit_emitter__&&"number"==typeof i.__signal_exit_emitter__.count&&(r+=i.__signal_exit_emitter__.count),n.length===r){this.unload();const n=this.#t.emit("exit",null,t),r="SIGHUP"===t?this.#e:t;n||e.kill(e.pid,r)}};this.#i=e.reallyExit,this.#r=e.emit}onExit(e,t){if(!Lr(this.#n))return()=>{};!1===this.#s&&this.load();const n=t?.alwaysLast?"afterExit":"exit";return this.#t.on(n,e),()=>{this.#t.removeListener(n,e),0===this.#t.listeners.exit.length&&0===this.#t.listeners.afterExit.length&&this.unload()}}load(){if(!this.#s){this.#s=!0,this.#t.count+=1;for(const e of Br)try{const t=this.#o[e];t&&this.#n.on(e,t)}catch(e){}this.#n.emit=(e,...t)=>this.#a(e,...t),this.#n.reallyExit=e=>this.#c(e)}}unload(){this.#s&&(this.#s=!1,Br.forEach((e=>{const t=this.#o[e];if(!t)throw new Error("Listener not defined for signal: "+e);try{this.#n.removeListener(e,t)}catch(e){}})),this.#n.emit=this.#r,this.#n.reallyExit=this.#i,this.#t.count-=1)}#c(e){return Lr(this.#n)?(this.#n.exitCode=e||0,this.#t.emit("exit",this.#n.exitCode,null),this.#i.call(this.#n,this.#n.exitCode)):0}#a(e,...t){const n=this.#r;if("exit"===e&&Lr(this.#n)){"number"==typeof t[0]&&(this.#n.exitCode=t[0]);const r=n.call(this.#n,e,...t);return this.#t.emit("exit",this.#n.exitCode,null),r}return n.call(this.#n,e,...t)}}(_r):new class extends Ur{onExit(){return()=>{}}load(){}unload(){}}),Hr=(e,t="SIGTERM",n={})=>{const r=e(t);return Kr(e,t,n,r),r},Kr=(e,t,n,r)=>{if(!zr(t,n,r))return;const i=Wr(n),o=setTimeout((()=>{e("SIGKILL")}),i);o.unref&&o.unref()},zr=(e,{forceKillAfterTimeout:t},n)=>Vr(e)&&!1!==t&&n,Vr=e=>e===l.constants.signals.SIGTERM||"string"==typeof e&&"SIGTERM"===e.toUpperCase(),Wr=({forceKillAfterTimeout:e=!0})=>{if(!0===e)return 5e3;if(!Number.isFinite(e)||e<0)throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`);return e},Xr=(e,t)=>{e.kill()&&(t.isCanceled=!0)},Yr=(e,{timeout:t,killSignal:n="SIGTERM"},r)=>{if(0===t||void 0===t)return r;let i;const o=new Promise(((r,o)=>{i=setTimeout((()=>{((e,t,n)=>{e.kill(t),n(Object.assign(new Error("Timed out"),{timedOut:!0,signal:t}))})(e,n,o)}),t)})),s=r.finally((()=>{clearTimeout(i)}));return Promise.race([o,s])},qr=(e,t,n)=>{if("string"==typeof n)return e[t].pipe(y(n)),e;if(wt(n))return e[t].pipe(n),e;if(!(e=>e instanceof i&&"function"==typeof e.then)(n))throw new TypeError("The second argument must be a string, a stream or an Execa child process.");if(!wt(n.stdin))throw new TypeError("The target child process's stdin must be available.");return e[t].pipe(n.stdin),n},Zr=async(e,{init:t,convertChunk:n,getSize:r,truncateChunk:i,addChunk:o,getFinalChunk:s,finalize:a},{maxBuffer:c=Number.POSITIVE_INFINITY}={})=>{if(!ti(e))throw new Error("The first argument must be a Readable, a ReadableStream, or an async iterable.");const d=t();d.length=0;try{for await(const t of e){const e=n[ni(t)](t,d);Jr({convertedChunk:e,state:d,getSize:r,truncateChunk:i,addChunk:o,maxBuffer:c})}return Qr({state:d,convertChunk:n,getSize:r,truncateChunk:i,addChunk:o,getFinalChunk:s,maxBuffer:c}),a(d)}catch(e){throw e.bufferedData=a(d),e}},Qr=({state:e,getSize:t,truncateChunk:n,addChunk:r,getFinalChunk:i,maxBuffer:o})=>{const s=i(e);void 0!==s&&Jr({convertedChunk:s,state:e,getSize:t,truncateChunk:n,addChunk:r,maxBuffer:o})},Jr=({convertedChunk:e,state:t,getSize:n,truncateChunk:r,addChunk:i,maxBuffer:o})=>{const s=n(e),a=t.length+s;if(a<=o)return void ei(e,t,i,a);const c=r(e,o-t.length);throw void 0!==c&&ei(c,t,i,o),new ii},ei=(e,t,n,r)=>{t.contents=n(e,t,r),t.length=r},ti=e=>"object"==typeof e&&null!==e&&"function"==typeof e[Symbol.asyncIterator],ni=e=>{const t=typeof e;if("string"===t)return"string";if("object"!==t||null===e)return"others";if(globalThis.Buffer?.isBuffer(e))return"buffer";const n=ri.call(e);return"[object ArrayBuffer]"===n?"arrayBuffer":"[object DataView]"===n?"dataView":Number.isInteger(e.byteLength)&&Number.isInteger(e.byteOffset)&&"[object ArrayBuffer]"===ri.call(e.buffer)?"typedArray":"others"},{toString:ri}=Object.prototype;class ii extends Error{name="MaxBufferError";constructor(){super("maxBuffer exceeded")}}const oi=e=>{throw new Error(`Streams in object mode are not supported: ${String(e)}`)},si=e=>e.length;const ai=new TextEncoder,ci=e=>new Uint8Array(e),di=e=>new Uint8Array(e.buffer,e.byteOffset,e.byteLength),ui=(e,t)=>{if(t<=e.byteLength)return e;const n=new ArrayBuffer(pi(t));return new Uint8Array(n).set(new Uint8Array(e),0),n},li=(e,t)=>{if(t<=e.maxByteLength)return e.resize(t),e;const n=new ArrayBuffer(t,{maxByteLength:pi(t)});return new Uint8Array(n).set(new Uint8Array(e),0),n},pi=e=>mi**Math.ceil(Math.log(e)/Math.log(mi)),mi=2,fi=()=>"resize"in ArrayBuffer.prototype,hi={init:()=>({contents:new ArrayBuffer(0)}),convertChunk:{string:e=>ai.encode(e),buffer:ci,arrayBuffer:ci,dataView:di,typedArray:di,others:oi},getSize:si,truncateChunk:(e,t)=>e.slice(0,t),addChunk:(e,{contents:t,length:n},r)=>{const i=fi()?li(t,r):ui(t,r);return new Uint8Array(i).set(e,n),i},getFinalChunk:()=>{},finalize:({contents:e,length:t})=>fi()?e:e.slice(0,t)};async function gi(e,t){if(!("Buffer"in globalThis))throw new Error("getStreamAsBuffer() is only supported in Node.js");try{return bi(await async function(e,t){return Zr(e,hi,t)}(e,t))}catch(e){throw void 0!==e.bufferedData&&(e.bufferedData=bi(e.bufferedData)),e}}const bi=e=>globalThis.Buffer.from(e);const yi=(e,{textDecoder:t})=>t.decode(e,{stream:!0}),wi={init:()=>({contents:"",textDecoder:new TextDecoder}),convertChunk:{string:e=>e,buffer:yi,arrayBuffer:yi,dataView:yi,typedArray:yi,others:oi},getSize:si,truncateChunk:(e,t)=>e.slice(0,t),addChunk:(e,{contents:t})=>t+e,getFinalChunk:({textDecoder:e})=>{const t=e.decode();return""===t?void 0:t},finalize:({contents:e})=>e},xi=({input:e,inputFile:t})=>"string"!=typeof t?e:((e=>{if(void 0!==e)throw new TypeError("The `input` and `inputFile` options cannot be both set.")})(e),w(t)),Si=async(e,t)=>{if(e&&void 0!==t){await x(0),e.destroy();try{return await t}catch(e){return e.bufferedData}}},Ii=(e,{encoding:t,buffer:n,maxBuffer:r})=>{if(e&&n)return"utf8"===t||"utf-8"===t?async function(e,t){return Zr(e,wi,t)}(e,{maxBuffer:r}):null===t||"buffer"===t?gi(e,{maxBuffer:r}):vi(e,r,t)},vi=async(e,t,n)=>(await gi(e,{maxBuffer:t})).toString(n),Ei=(async()=>{})().constructor.prototype,Ti=["then","catch","finally"].map((e=>[e,Reflect.getOwnPropertyDescriptor(Ei,e)])),Ci=(e,t)=>{for(const[n,r]of Ti){const i="function"==typeof t?(...e)=>Reflect.apply(r.value,t(),e):r.value.bind(t);Reflect.defineProperty(e,n,{...r,value:i})}},Gi=(e,t=[])=>Array.isArray(t)?[e,...t]:[e],Pi=/^[\w.-]+$/,Ai=(e,t)=>Gi(e,t).map((e=>(e=>"string"!=typeof e||Pi.test(e)?e:`"${e.replaceAll('"','\\"')}"`)(e))).join(" "),ki=S("execa").enabled,Oi=(e,t)=>String(e).padStart(t,"0"),Bi=(t,{verbose:n})=>{n&&e.stderr.write(`[${(()=>{const e=new Date;return`${Oi(e.getHours(),2)}:${Oi(e.getMinutes(),2)}:${Oi(e.getSeconds(),2)}.${Oi(e.getMilliseconds(),3)}`})()}] ${t}\n`)},Li=(t,r,i={})=>{const o=be._parse(t,r,i);return t=o.command,r=o.args,(i={maxBuffer:1e8,buffer:!0,stripFinalNewline:!0,extendEnv:!0,preferLocal:!1,localDir:(i=o.options).cwd||e.cwd(),execPath:e.execPath,encoding:"utf8",reject:!0,cleanup:!0,all:!1,windowsHide:!0,verbose:ki,...i}).env=(({env:t,extendEnv:n,preferLocal:r,localDir:i,execPath:o})=>{const s=n?{...e.env,...t}:t;return r?xe({env:s,cwd:i,execPath:o}):s})(i),i.stdio=Or(i),"win32"===e.platform&&"cmd"===n.basename(t,".exe")&&r.unshift("/q"),{file:t,args:r,options:i,parsed:o}},Ri=(e,n,r)=>"string"==typeof n||t.isBuffer(n)?e.stripFinalNewline?ye(n):n:void 0===r?void 0:"";function $i(e,t,n){const i=Li(e,t,n),o=((e,t)=>Gi(e,t).join(" "))(e,t),s=Ai(e,t);let a;Bi(s,i.options),(({timeout:e})=>{if(void 0!==e&&(!Number.isFinite(e)||e<0))throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`)})(i.options);try{a=r.spawn(i.file,i.args,i.options)}catch(e){const t=new r.ChildProcess,n=Promise.reject(Ar({error:e,stdout:"",stderr:"",all:"",command:o,escapedCommand:s,parsed:i,timedOut:!1,isCanceled:!1,killed:!1}));return Ci(t,n),t}const c=(e=>new Promise(((t,n)=>{e.on("exit",((e,n)=>{t({exitCode:e,signal:n})})),e.on("error",(e=>{n(e)})),e.stdin&&e.stdin.on("error",(e=>{n(e)}))})))(a),d=Yr(a,i.options,c),u=(async(e,{cleanup:t,detached:n},r)=>{if(!t||n)return r;const i=Dr((()=>{e.kill()}));return r.finally((()=>{i()}))})(a,i.options,d);a.kill=Hr.bind(null,a.kill.bind(a)),a.cancel=Xr.bind(null,a,{isCanceled:!1});const l=Pe((async()=>{const[{error:e,exitCode:t,signal:n,timedOut:r},c,d,l]=await(async({stdout:e,stderr:t,all:n},{encoding:r,buffer:i,maxBuffer:o},s)=>{const a=Ii(e,{encoding:r,buffer:i,maxBuffer:o}),c=Ii(t,{encoding:r,buffer:i,maxBuffer:o}),d=Ii(n,{encoding:r,buffer:i,maxBuffer:2*o});try{return await Promise.all([s,a,c,d])}catch(r){return Promise.all([{error:r,signal:r.signal,timedOut:r.timedOut},Si(e,a),Si(t,c),Si(n,d)])}})(a,i.options,u),p=Ri(i.options,c),m=Ri(i.options,d),f=Ri(i.options,l);if(e||0!==t||null!==n){const c=Ar({error:e,exitCode:t,signal:n,stdout:p,stderr:m,all:f,command:o,escapedCommand:s,parsed:i,timedOut:r,isCanceled:!!i.options.signal&&i.options.signal.aborted,killed:a.killed});if(!i.options.reject)return c;throw c}return{command:o,escapedCommand:s,exitCode:0,stdout:p,stderr:m,all:f,failed:!1,timedOut:!1,isCanceled:!1,killed:!1}}));return((e,t)=>{const n=xi(t);void 0!==n&&(yt(n)?n.pipe(e.stdin):e.stdin.end(n))})(a,i.options),a.all=((e,{all:t})=>{if(!t||!e.stdout&&!e.stderr)return;const n=Ot();return e.stdout&&n.add(e.stdout),e.stderr&&n.add(e.stderr),n})(a,i.options),(e=>{null!==e.stdout&&(e.pipeStdout=qr.bind(void 0,e,"stdout")),null!==e.stderr&&(e.pipeStderr=qr.bind(void 0,e,"stderr")),void 0!==e.all&&(e.pipeAll=qr.bind(void 0,e,"all"))})(a),Ci(a,l),a}const ji=async e=>{const{stdout:t}=await $i("netstat",["-anv","-p",e]);return t},Ni="darwin"===e.platform?async()=>(await Promise.all([ji("tcp"),ji("udp")])).join("\n"):"linux"===e.platform?async()=>{const{stdout:e}=await $i("ss",["-tunlp"]);return e}:async()=>{const{stdout:e}=await $i("netstat",["-ano"]);return e},Ui="darwin"===e.platform?3:"linux"===e.platform?4:1,_i="darwin"===e.platform?8:"linux"===e.platform?6:4,Di=(e,t)=>{const n=new RegExp(`[.:]${e}$`),r=t.find((e=>n.test(e[Ui])));if(!r)throw new Error(`Could not find a process that uses port \`${e}\``);return(e=>{if("string"!=typeof e)return;const{groups:t}=/(?:^|",|",pid=)(?<pid>\d+)/.exec(e)||{};return t?Number.parseInt(t.pid,10):void 0})(r[_i])},Fi=async()=>(await Ni()).split("\n").filter((e=>/^\s*(tcp|udp)/i.test(e))).map((e=>e.match(/\S+/g)||[]));const Mi=n.dirname(d(import.meta.url)),Hi=1e7,Ki=I(r.execFile),zi=/^[ \t]*(?<pid>\d+)[ \t]+(?<ppid>\d+)[ \t]+(?<uid>[-\d]+)[ \t]+(?<cpu>\d+\.\d+)[ \t]+(?<memory>\d+\.\d+)[ \t]+(?<comm>.*)?/,Vi="win32"===e.platform?async()=>{let t;switch(e.arch){case"x64":t="fastlist-0.3.0-x64.exe";break;case"ia32":t="fastlist-0.3.0-x86.exe";break;default:throw new Error(`Unsupported architecture: ${e.arch}`)}const r=n.join(Mi,"vendor",t),{stdout:i}=await Ki(r,{maxBuffer:Hi,windowsHide:!0});return i.trim().split("\r\n").map((e=>e.split("\t"))).map((([e,t,n])=>({pid:Number.parseInt(e,10),ppid:Number.parseInt(t,10),name:n})))}:async(e={})=>{try{return await(async(e={})=>{const t=!1===e.all?"wwxo":"awwxo",r=[Ki("ps",[t,"pid,ppid,uid,%cpu,%mem,comm"],{maxBuffer:Hi}),Ki("ps",[t,"pid,args"],{maxBuffer:Hi})],[i,o]=(await Promise.all(r)).map((({stdout:e})=>e.trim().split("\n"))),s=new Set(r.map((e=>e.child.pid)));i.shift(),o.shift();const a={};for(const e of o){const[t,n]=e.trim().split(" ");a[t]=n.join(" ")}return i.map((e=>{const t=zi.exec(e);if(null===t)throw new Error("ps output parsing failed");const{pid:r,ppid:i,uid:o,cpu:s,memory:c,comm:d}=t.groups;return{pid:Number.parseInt(r,10),ppid:Number.parseInt(i,10),uid:Number.parseInt(o,10),cpu:Number.parseFloat(s),memory:Number.parseFloat(c),name:n.basename(d),cmd:a[r]}})).filter((e=>!s.has(e.pid)))})(e)}catch{return(async(e={})=>{const t=(!1===e.all?"":"a")+"wwxo",r={};return await Promise.all(["comm","args","ppid","uid","%cpu","%mem"].map((async e=>{const{stdout:n}=await Ki("ps",[t,`pid,${e}`],{maxBuffer:Hi});for(let t of n.trim().split("\n").slice(1)){t=t.trim();const[n]=t.split(" ",1),i=t.slice(n.length+1).trim();void 0===r[n]&&(r[n]={}),r[n][e]=i}}))),Object.entries(r).filter((([,e])=>e.comm&&e.args&&e.ppid&&e.uid&&e["%cpu"]&&e["%mem"])).map((([e,t])=>({pid:Number.parseInt(e,10),name:n.basename(t.comm),cmd:t.args,ppid:Number.parseInt(t.ppid,10),uid:Number.parseInt(t.uid,10),cpu:Number.parseFloat(t["%cpu"]),memory:Number.parseFloat(t["%mem"])})))})(e)}},Wi="linux"===e.platform?(e,t)=>"string"==typeof e?t.name===e||t.cmd.split(" ")[0]===e:t.pid===e:(e,t)=>"string"==typeof e?t.name===e:t.pid===e;async function Xi(e){const t=await Vi();return e.filter((e=>t.some((t=>Wi(e,t)))))}const Yi=e=>new Promise((t=>{setTimeout(t,e)})),qi=async(e,t)=>{try{return await mr(e,t)}catch(t){if("ENOENT"===t.code){const n=new Error(`\`${e}\` doesn't seem to be installed and is required by fkill`);throw n.sourceError=t,n}throw t}},Zi=async(e,t)=>{try{return await Xt(e,{force:t.force,tree:void 0===t.tree||t.tree})}catch(e){if(255===e.exitCode&&!t.force)return;throw e}},Qi=(e,t)=>{const n="string"==typeof e,r=n?"pkill":"kill",i=[e];return n&&t.ignoreCase&&i.unshift("-i"),n&&i.unshift("-x"),t.force&&(n?i.unshift("-KILL"):i.unshift("-9")),qi(r,i)},Ji=(e,t)=>{const n="string"==typeof e,r=n?"killall":"kill",i=[e];return t.force&&i.unshift("-9"),n&&t.ignoreCase&&i.unshift("-I"),qi(r,i)},eo="darwin"===e.platform?Qi:"win32"===e.platform?Zi:Ji,to=async e=>"string"==typeof e&&":"===e[0]?async function(e){if(Array.isArray(e)){const t=await Fi(),n=await Promise.all(e.map((e=>[e,Di(e,t)])));return new Map(n)}if(!Number.isInteger(e))throw new TypeError("Expected an integer, got "+typeof e);return Di(e,await Fi())}(Number.parseInt(e.slice(1),10)):e,no=async(t,n)=>{if((t=await to(t))!==e.pid)if("node"!==t&&"node.exe"!==t)await eo(t,n);else{const t=await Vi(),r=(t=>{const n=new Map(t.map((e=>[e.pid,e.ppid]))),r=[];let i=e.pid;for(;i;)r.push(i),i=n.get(i);return r})(t);await Promise.all(t.map((async e=>{"node"!==e.name&&"node.exe"!==e.name||r.includes(e.pid)||await eo(e.pid,n)})))}};async function ro(e,t={}){e=[e].flat();const n=await async function(e){const t=await Vi();return new Map(e.map((e=>[e,t.some((t=>Wi(e,t)))])))}(e),r=[];if(await Promise.all(e.map((e=>(async e=>{try{await no(e,t)}catch(t){if(!n.get(e))return void r.push(`Killing process ${e} failed: Process doesn't exist`);r.push(`Killing process ${e} failed: ${t.message.replace(/.*\n/,"").replace(/kill: \d+: /,"").trim()}`)}})(e)))),r.length>0&&!t.silent)throw new yr(r);if(void 0!==t.forceAfterTimeout&&!t.force){const n=Date.now()+t.forceAfterTimeout;let r=5;r>t.forceAfterTimeout&&(r=t.forceAfterTimeout);let i=e;do{await Yi(r),i=await Xi(i),r*=2,r>1280&&(r=1280)}while(Date.now()<n&&i.length>0);i.length>0&&await Promise.all(i.map((async e=>{try{await no(e,{...t,force:!0})}catch{}})))}}var io={id:"kill_port",handler:async({port:e})=>{try{return await ro(`:${e}`,{force:!0}),{message:`Port ${e} has been successfully terminated`}}catch(e){throw{error:e}}}};export{io as default};
